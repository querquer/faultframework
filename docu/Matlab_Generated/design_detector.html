
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>DESIGN_DETECTOR</title><meta name="generator" content="MATLAB 8.3"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2015-03-17"><meta name="DC.source" content="design_detector.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>DESIGN_DETECTOR</h1><!--introduction--><p>This function represents the core of the automated configuration of a sensor fault detector. The algorithm is based on an optimization algorithm, namely a genetic algorithm. Using the function 'generate_starting_point', 'output_detector' and 'create_detector' allows the optimization algorithm to determine the best configuration 'x' of the specified type of sensor fault detectors. The function 'generate_starting_point' returns an initial configuration 'x'. Based on such a configuration, 'output_detector' produces a sample output, which is evaluated in terms of false-positives and false-negatives. Both values are used for assesing configurations. Due to the genetic algorithm and based on the implementation of the detector dependend functions ('generate_starting_point', 'output_detecotr', 'create_detector') the run time of this function can increase up to several hours.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Input Parameters</a></li><li><a href="#2">Optional Parameters</a></li><li><a href="#3">Implementation</a></li></ul></div><h2>Input Parameters<a name="1"></a></h2><div><ul><li>'data': Array of structures with field 'name' specifying the fault type represented by this sample data and field 'data' which contains the sample data. Every entry represents a different fault type.</li><li>'trigger': Array of structures with field 'name specifying the fault type represented by this sample data and field 'trigger' which is another array consisting of zeros (sample data at the same index in 'data' is not faulty) and ones (sample data at the same index in 'data' is faulty).</li><li>'sampletime': The resulting Simulink model representing the designed detector will have this Sample Time.</li><li>'max_delay': Defines the maximum delay of an detection result. If a failure occured at time t = 0, the detector will detect it at least at t = 'sampletime' * 'max_delay'. 'max_delay' has to be a natural number.</li><li>'grad_thr': This value is a threshold for limiting the computation time of the optimization algorithm and is used to specify the 'function tolerance' of the genetic algorithm. For more information on this parameter see: <a href="http://de.mathworks.com/help/gads/genetic-algorithm-options.html#f8335">FunctionTolerance</a></li><li>'path_and_name': Defines the output path and name of the resulting sensor fault detector.</li><li>'path_detector': Defines the path of the used detector. This path is used to search for the detector specific functions 'generate_starting_point', 'output_detector' and 'create_detector'.</li><li>'evaluation_model': Defines the path and the name of the simulink model used to evaluate the resulting detector in terms of false-negatives and false-positives.</li></ul></div><h2>Optional Parameters<a name="2"></a></h2><p>Using a genetic algorithm to design a sensor fault detector can have disadvantages concerning the computation time. Depending on the implementation of 'output_detector', which is called for every evaluation made by the genetic algorithm, the computation time can increase. Therefore it can be beneficial to set parameters of the genetic algorithm based on the knowledge about the current type of detector. Hence, an optional function 'set_ga_options' can be implemented which is called right before starting the genetic algorithm.</p><h2>Implementation<a name="3"></a></h2><pre class="codeinput"><span class="keyword">function</span> [x, fval, exitflag, FN_final, FP_final] = design_detector(data, trigger, sampletime, max_delay, grad_thr, path_and_name, path_detector, evaluation_model)
</pre><pre class="codeinput"><span class="comment">%get function handles</span>
[fun_starting_point,fun_config_dependend_output, fun_create, fun_ga_options] = find_functions(path_detector);
</pre><pre class="codeinput"><span class="comment">%generate starting point for optimisation. This function must be</span>
<span class="comment">%implemented by the detector itself.</span>
sd = size(data);
x = feval(fun_starting_point, sd(1,2));
</pre><pre class="codeinput"><span class="comment">%try to open a parallelisation pool in order to enable possible</span>
<span class="comment">%sub-routines to make use of it.</span>
<span class="keyword">try</span>
    pool = parpool();
<span class="keyword">catch</span> err
<span class="keyword">end</span>
</pre><p>Definition of fitness-function</p><pre class="codeinput">    <span class="keyword">function</span> FNFP = opt_fun(x)

            <span class="comment">%get detection results for test data. This function must be</span>
            <span class="comment">%implemented by the detector itself.</span>
            <span class="comment">%det has to match to the format of 'trigger'</span>
            det = feval(fun_config_dependend_output, x,data, trigger);
            <span class="comment">%calculate false-positve and false-negative rate</span>
            [FN, FP] = evaluation(trigger, det, max_delay);

            <span class="comment">%determine one value measuring the performance of the system in</span>
            <span class="comment">%order to avoid multi-objectiv optimisation. Possible</span>
            <span class="comment">%future-work: use multi-objectiv optimisation here!</span>
            sf = size(FN);
            sum = 0;
            <span class="keyword">for</span> i = 1:sf(1,2);
                sum = sum + (FN(i).fn_rate + FP(i).fp_rate)/2;

            <span class="keyword">end</span>

            FNFP = sum/sf(1,2);
    <span class="keyword">end</span>
</pre><pre class="codeinput"><span class="comment">%configure genetic algorithm</span>
sx = size(x);
options = gaoptimset(<span class="string">'TolFun'</span>, grad_thr);
options = gaoptimset(options,<span class="string">'Display'</span>, <span class="string">'iter'</span>);
options = gaoptimset(options,<span class="string">'UseParallel'</span>, true);

<span class="keyword">if</span>(sx(1,2) &lt;= 5)
    options = gaoptimset(options,<span class="string">'PopulationSize'</span>,25);
<span class="keyword">else</span>
    options = gaoptimset(options,<span class="string">'PopulationSize'</span>,50);
<span class="keyword">end</span>

<span class="comment">%check whether there are detector specific setting for ga-options</span>
<span class="keyword">if</span>(isempty(fun_ga_options) == 0)
    options = feval(fun_ga_options, options);
<span class="keyword">end</span>
</pre><p>Start optimization with respect to defined options.</p><pre class="codeinput">[x,fval,exitflag] = ga(@opt_fun,sx(1,2),[],[],[],[],[],[],[],options);
</pre><pre class="codeinput"><span class="comment">%create detector as Simulink-Model. This function must be implemented by</span>
<span class="comment">%the detector itself.</span>
curr_dir = pwd;
cd(path_detector);
feval(fun_create, x, data, trigger, max_delay, path_and_name);
cd(curr_dir);
</pre><pre class="codeinput"><span class="comment">%use Evaluation.slx to get final fn/fp-rates.</span>
[path, name] = extract_path(path_and_name);
addpath(path);

out = run_evaluation_model(data, sampletime, name, evaluation_model);
[FN_final, FP_final] = evaluation(trigger, out, max_delay);
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2014a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% DESIGN_DETECTOR 
% This function represents the core of the automated configuration of a
% sensor fault detector. The algorithm is based on an optimization
% algorithm, namely a genetic algorithm. Using the function
% 'generate_starting_point', 'output_detector' and 'create_detector' allows
% the optimization algorithm to determine the best configuration 'x' of the
% specified type of sensor fault detectors. The function
% 'generate_starting_point' returns an initial configuration 'x'. Based on
% such a configuration, 'output_detector' produces a sample output, which
% is evaluated in terms of false-positives and false-negatives. Both values
% are used for assesing configurations. Due to the genetic algorithm and
% based on the implementation of the detector dependend functions
% ('generate_starting_point', 'output_detecotr', 'create_detector') the run
% time of this function can increase up to several hours.

%% Input Parameters
% * 'data': Array of structures with field 'name' specifying the fault type
% represented by this sample data and field 'data' which contains the
% sample data. Every entry represents a different fault type. 
% * 'trigger': Array of structures with field 'name specifying the fault
% type represented by this sample data and field 'trigger' which is another
% array consisting of zeros (sample data at the same index in 'data' is not
% faulty) and ones (sample data at the same index in 'data' is faulty).
% * 'sampletime': The resulting Simulink model representing the designed
% detector will have this Sample Time. 
% * 'max_delay': Defines the maximum delay of an detection result. If a
% failure occured at time t = 0, the detector will detect it at least at t
% = 'sampletime' * 'max_delay'. 'max_delay' has to be a natural number.
% * 'grad_thr': This value is a threshold for limiting the computation time
% of the optimization algorithm and is used to specify the
% 'function tolerance' of the genetic algorithm. For more information on
% this parameter see:
% <http://de.mathworks.com/help/gads/genetic-algorithm-options.html#f8335
% FunctionTolerance>
% * 'path_and_name': Defines the output path and name of the resulting
% sensor fault detector.
% * 'path_detector': Defines the path of the used detector. This path is
% used to search for the detector specific functions
% 'generate_starting_point', 'output_detector' and 'create_detector'.
% * 'evaluation_model': Defines the path and the name of the simulink model 
% used to evaluate the resulting detector in terms of false-negatives and false-positives. 

%% Optional Parameters
% Using a genetic algorithm to design a sensor fault detector can have
% disadvantages concerning the computation time. Depending on the
% implementation of 'output_detector', which is called for every evaluation
% made by the genetic algorithm, the computation time can increase.
% Therefore it can be beneficial to set parameters of the genetic algorithm
% based on the knowledge about the current type of detector. Hence, an
% optional function 'set_ga_options' can be implemented which is called
% right before starting the genetic algorithm.

%% Implementation

function [x, fval, exitflag, FN_final, FP_final] = design_detector(data, trigger, sampletime, max_delay, grad_thr, path_and_name, path_detector, evaluation_model)

%get function handles
[fun_starting_point,fun_config_dependend_output, fun_create, fun_ga_options] = find_functions(path_detector);

%%
%generate starting point for optimisation. This function must be
%implemented by the detector itself.
sd = size(data);
x = feval(fun_starting_point, sd(1,2));

%%
%try to open a parallelisation pool in order to enable possible
%sub-routines to make use of it.
try
    pool = parpool();
catch err
end
%%
% Definition of fitness-function
    function FNFP = opt_fun(x)
          
            %get detection results for test data. This function must be
            %implemented by the detector itself.
            %det has to match to the format of 'trigger'
            det = feval(fun_config_dependend_output, x,data, trigger);
            %calculate false-positve and false-negative rate
            [FN, FP] = evaluation(trigger, det, max_delay);
            
            %determine one value measuring the performance of the system in
            %order to avoid multi-objectiv optimisation. Possible
            %future-work: use multi-objectiv optimisation here!
            sf = size(FN);
            sum = 0;
            for i = 1:sf(1,2);
                sum = sum + (FN(i).fn_rate + FP(i).fp_rate)/2;

            end
            
            FNFP = sum/sf(1,2);
    end

  

%%
%configure genetic algorithm
sx = size(x);
options = gaoptimset('TolFun', grad_thr);
options = gaoptimset(options,'Display', 'iter');
options = gaoptimset(options,'UseParallel', true);

if(sx(1,2) <= 5)
    options = gaoptimset(options,'PopulationSize',25);
else
    options = gaoptimset(options,'PopulationSize',50);
end

%check whether there are detector specific setting for ga-options
if(isempty(fun_ga_options) == 0)
    options = feval(fun_ga_options, options);
end

%%
% Start optimization with respect to defined options.
    
[x,fval,exitflag] = ga(@opt_fun,sx(1,2),[],[],[],[],[],[],[],options);

%%
%create detector as Simulink-Model. This function must be implemented by
%the detector itself.
curr_dir = pwd;
cd(path_detector);
feval(fun_create, x, data, trigger, max_delay, path_and_name);
cd(curr_dir);

%%
%use Evaluation.slx to get final fn/fp-rates.
[path, name] = extract_path(path_and_name);
addpath(path);

out = run_evaluation_model(data, sampletime, name, evaluation_model);
[FN_final, FP_final] = evaluation(trigger, out, max_delay);
 
end


##### SOURCE END #####
--></body></html>